Zadaniem GUI jest monitorowanie magistrali CAN oraz akwizycja danych przesy³anych przez UART do programu. Program mo¿e pracowaæ w dwóch trybach:\newline
\begin{itemize}
	\item Offline- Wczytywanie danych z karty SD
	\item Online- Monitorowanie magistali CAN w czasie rzeczywistym
\end{itemize}
\subsection{Komunikacja UART}
Zdecydowano siê na komunikacje $UART$ w zwi¹zku z du¿¹ liczb¹ modu³ów bezprzewodowych obs³uguj¹cych ten typ transmisji.
Obs³uga komunikacji realizowana jest przez kontrolkê $SerialPort$, która jest czêœci¹ œrodowiska Visual Studio. Dostarcza ona metod pozwalaj¹cych na ³atw¹ obs³ugê portu szeregowego.
\subsection{Grphical User Interface (GUI)}
W g³ównym komputerze pomiarowym zaimplementowano zapis ramek przesy³anych przez magistrale bezpoœrednio na kartê SD. Stworzone przez nas GUI posiada opcje wczytania logu magistrali do programu oraz manipulowania danymi. \newline
\begin  {figure} [h] 
\centering
\includegraphics[width=\textwidth]{figures/GUI_Main.PNG}
\caption{G³ówne okno programu}
\label{fig:GUI_Main}
\end {figure}
Tryb online polega na przesy³aniu w czasie rzeczywistym ramek pojawiaj¹cych siê na magistrali. Przesy³ana jest ca³a ramka zakodowana w kodzie szesnastkowym przez magistrale UART. Po stronie programu ramka jest wczytywana do stringa. Nastêpnym krokiem jest wczytanie ramki do napisanej klasy $Frame$, która przechowuje ramki transmisyjne oraz udostêpnia akcessory do poszczególnych sk³adowych. \\newline
\begin{lstlisting}[captionpos=b, belowcaptionskip=8pt, caption=Lista mo¿liwych identyfikatorów CAN, label=listing:FrameMake]
 this.Orgin = Frame;
            Adres = Orgin.Substring(0, 8);
            DLC = Orgin.Substring(8, 2);
            iDLC = int.Parse(DLC,System.Globalization.NumberStyles.HexNumber) / 2;
            if (iDLC > 2)
            {
                Canal = new string[iDLC];
                Value = new double[iDLC];
                dCanal = new double[iDLC];
                FactorA = new double[iDLC];
                FactorB = new double[iDLC];
            }
            else
            {
                Canal = new string[2];
                Value = new double[2];
                dCanal = new double[2];
                FactorA = new double[2];
                FactorB = new double[2];
            }
            for (int i = 0; iDLC != i;i++ )
            {
                Canal[i] = Orgin.Substring(10+i*4, 4);
                
                dCanal[i] = int.Parse(Canal[i], System.Globalization.NumberStyles.HexNumber);
                Value[i] = dCanal[i];
                FactorA[i] = 1;
                FactorB[i]=0;
            }
\end{lstlisting}

Na \hyperref[listing:FrameMake]{Listingu~\ref*{listing:FrameMake}} widzimy odczytywanie pierwszych 4 bajtów adresu oraz d³ugoœci transmisji DLC. Nastêpnie jest ona parsowana z kodu szesnastkowego do zmiennej integer. Na podstawie d³ugoœci DLC tworzymy tablice w których zostan¹ ulokowane przes³ane pomiary. Przyjêto, ¿e ka¿dy kana³ pomiarowy bêdzie posiada³ swój adres, a pomiar bêdzie przesy³any w 2 bajtach danych. Klasa $Frame$ zosta³a przystosowana tak¿e do obs³ugi wielu 2 bajtowych zestawów danych, wys³anych przez jedn¹ ramkê.\newline
\begin  {figure} [h] 
\centering
\includegraphics[width=\textwidth]{figures/GUI_Main.PNG}
\caption{G³ówne okno programu}
\label{fig:GUI_Main}
\end {figure}
Po uruchomieniu programu mamy dostêp do rozwijanego menu w którym mo¿emy wybraæ na jakim porcie COM ma byæ prowadzony nas³uch lub mo¿liwoœæ wczytania danych w trybie offline przyciskiem $Load Data$, tak jak na \hyperref[fig:GUI_Main]{Rysunku~\ref*{fig:GUI_Main}}. Po pojawieniu siê ramki na magistrali lub wczytaniu danych z pliku w oknie dialogowym widzimy z jakich adresów przychodzi³y pomiary. Na pozycji Canal widzimy pomiar szesnastkowo, który zosta³ wys³any z uk³adu pomiarowego. Wartoœæ pozycji Value jest przeskalowana przez wspó³czynniki $a$ i $b$ które domyœlnie s¹ ustawione na $1$ i $0$. Aplikacja oferuje mo¿liwoœæ nazwania sygna³u oraz napisania komentarza co pozwala ³atwiej operowaæ na przychodz¹cych danych. Na tej karcie mo¿na obserwowaæ tylko ostatni¹ próbkê, która pojawi³a siê na magistrali.\newline

\begin  {figure} [h] 
\centering
\includegraphics[width=\textwidth]{figures/GUI_Chart.PNG}
\caption{Okno wykresu}
\label{fig:GUI_Chart}
\end {figure}
Dwukrotne klikniêcie na sygna³ lub zaznaczenie paru sygna³ów i naciœniêcie klawisza $Enter$ powoduje otwarcie okna wykresu danego sygna³u. W oknie wykresu mo¿emy obserwowaæ w czasie rzeczywistym lub offline przebieg sygna³u odczytywanego z magistrali. Przy u¿yciu menu rozwijanego $Chart$ mo¿emy decydowaæ, które sygna³y chcemy obserwowaæ na wykresie.\newline
\begin  {figure} [h] 
\centering
\includegraphics[width=0.5\textwidth]{figures/GUI_Menu.PNG}
\caption{Menu w oknie Chart}
\label{fig:GUI_Chart}
\end {figure}
Menu $File$ w oknie wykresy dostarcza takich opcji jak zapis wykresu do obrazu lub generowanie pliku w formacie odczytywanym przez programy kalkulacyjne.\newline
GUI dostarcza mo¿liwoœæ pracy na stanowiskach wielomonitorowych. Mo¿emy otworzyæ okno wykresu dla ka¿dego kana³u przesy³anego po magistrali CAN i rozmieœciæ je w wygodny dla u¿ytkownika sposób.\newline
\begin  {figure} [h] 
\centering
\includegraphics[width=0.8\textwidth]{figures/GUI_All.PNG}
\caption{Praca z wykresami}
\label{fig:GUI_Chart}
\end {figure}