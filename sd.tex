\section{Archiwizacja danych - SD} \label{sec:sd}
Mimo i¿ dane s¹ na bie¿¹co wysy³ane do zdalnego interfejsu u¿ytkownika, trzeba wzi¹æ pod uwagê awaryjnoœæ takiego przesy³u oraz mo¿liwoœæ gubienia pakietów danych przy du¿ych odleg³oœciach. Potrzebny jest stabilny i szybki system zapisu zebranych danych, który bêdzie niezale¿ny od bezprzewodowej komunikacji. Wybrano zapis danych na kartê SD pod³¹czon¹ bezpoœrednio do g³ównego komputera pok³adowego. Standard kart SD jest standardem opracowanym przez trzech producentów: Toshiba, SanDisk i MEI~\cite{manual:sandisk}, który wyewoluowa³ ze starszego standardu MultiMediaCard (MMC). Zarówno budowa samej karty, po³¹czenia elektryczne jak i protokó³ s¹ czêœci¹ specyfikacji SD Card (SDC), podzielonej na wiele mniejszych dokumentów~\cite{spec:sd}\cite{spec:sdio}. SDC oferuje zaawansowany interfejs 9 linii elektrycznych (zegarowej, komend, 4 linie danych i 3 linie zasilania), który mo¿e pracowaæ z maksymaln¹ czêstotliwoœci¹ 50~MHz~\cite{spec:sd}.(\hyperref[fig:sd]{Rysunek~\ref*{fig:sd}}).
\begin{figure} [h]
	\centering
	\begin{minipage}[c]{0.25\linewidth}
		\centering \includegraphics[width=0.75\linewidth]{figures/SD_diagram.JPG}
	\end{minipage}%
	\begin{minipage}[c]{0.75\linewidth}
		\centering \includegraphics[width=\linewidth]{figures/SD_pinout.JPG}
	\end{minipage}
	\caption{Diagram Karty SD~\cite{manual:sandisk}}
	\label{fig:sd}
\end{figure}

Z \hyperref[fig:sd]{Rysunku~\ref*{fig:sd}} wynika, ¿e karty SD wspieraj¹ dwa fizyczne protoko³y komunikacyjne: SD Bus (\hyperref[sec:sub:sdbus]{Sekcja~\ref*{sec:sub:sdbus}: SD Bus}) oraz SPI (\hyperref[sec:sub:spi]{Sekcja~\ref*{sec:sub:spi}: Serial Peripheral Interface (SPI)}).\\
Protokó³ komunikacyjny kart SD opiera siê na prostym systemie komend i odpowiedzi. Wszystkie komendy s¹ inicjowane przez mastera. Karta SD odpowiada na zapytanie ramk¹ odpowiedzi, po której mo¿e nast¹piæ przesy³ danych, je¿eli taka by³a komenda, lub zg³oszenie b³êdu. Ca³y protokó³ s³u¿y do obs³ugi systemu plików zawartego na karcie. 

\subsection{FatFs} \label{sec:sub:fat}
Z perspektywy systemu plików ka¿dy noœnik danych podzielony jest na klastry i sektory. Sektory s¹ zazwyczaj d³ugoœci 512 bajtów, natomiast klastry przyjmuj¹ ró¿ne wartoœci, w zale¿noœci od pojemnoœci dysku i rodzaju systemu plików. Pliki zapisywane s¹ w klastrach, zajmuj¹c je ca³kowicie. Oznacza to, ¿e gdy plik jest mniejszy od pojedynczego klastra, ca³y klaster zostanie przypisany do tego pliku. System plików FAT opiera siê na tablicy alokacji plików FAT (File Allocation Table). Jest to tablica, która stanowi katalog plików znajduj¹cych siê na danej partycji/dysku~\cite{book:paprocki}.\\ 
FatFs to biblioteka implementuj¹ca system plików FAT dla systemów wbudowanych. Jest to pomost ³¹cz¹cy warstwê sprzêtow¹ z warstw¹ aplikacji. Niezale¿nie od platformy sprzêtowej, po zdefiniowaniu podstawowych funkcji, system zadzia³a na wybranej platformie sprzêtowej. Minimalna aplikacja zak³ada, ¿e u¿ytkownik napisze funkcje odpowiedzialne za wys³anie i odbiór wiadomoœci oraz inicjalizacjê karty. Dok³adny opis przewidywanego dzia³ania tych funkcji dostêpny jest na g³ównej stronie, z której pobrano bibliotekê~\cite{misc:fat}. Dodatkowo na stronie podane s¹ Ÿród³a, z których mo¿na pobraæ biblioteki oparte na FatFs implementuj¹ce j¹ na wybranych platformach sprzêtowych. Jedn¹ z takich bibliotek, autorstwa Tilen'a Majerle~\cite{lib:sd}, u¿yto w projekcie.

\subsection{SD Bus} \label{sec:sub:sdbus}
Protokó³ SD Bus dzieli siê na dwie wersje. Wyró¿nia siê wersjê 1-bitow¹ oraz 4-bitow¹.\\
SD Bus w wersji 1-bitowej to synchroniczny, szeregowy protokó³ z jedn¹ lini¹ komend, jedn¹ danych i jedn¹ zegarow¹.\\
SD Bus w wersji 4-bitowej ró¿ni siê od niego tylko szerokoœci¹ linii danych, których jest 4. Przy dobrej implementacji mo¿e byæ czterokrotnie szybszy ni¿ jego ubo¿sza wersja.\\
Protokó³ SD Bus wymaga obliczania sumy CRC, która zapobiega b³êdom transmisji. W przypadku wersji 4-bitowej, CRC liczone jest dla ka¿dej linii danych z osobna. SD Bus jest domyœlnym protoko³em do obs³ugi kart SD, aby prze³¹czyæ kartê w tryb SPI nale¿y podczas inicjalizacj u¿yæ specjalnej komendy i przekazaæ odpowiedni dla niej kod CRC~\cite{spec:sd}.

\subsection{Serial Peripheral Interface (SPI)} \label{sec:sub:spi}
Interfejs SPI s³u¿y do dwukierunkowej (full duplex) , synchronicznej, szeregowej komunikacji i sk³ada siê z trzech linii:
\begin{itemize}
\item MISO - Master Input Slave Output, jednokierunkowa linia danych s³u¿¹ca do odbierania danych przez mastera.
\item MOSI - Master Output Slave Input, jednokierunkowa linia danych s³u¿¹ca do wysy³ania danych przez mastera.
\item SCK - linia zegarowa s³u¿aca synchronizacji komunikacji~\cite{book:paprocki}.
\end{itemize}
Do aktywacji wybranego uk³adu peryferyjnego s³u¿y dodatkowo linia SS (Slave Select - wybór uk³adu podrzêdnego).\\
Jako ¿e podstaw¹ komunikacji z kartami SD est wymiana komend i danych, a SPI nie dysponuje lini¹ komend, wszystkie komendy i dane s¹ szeregowo wysy³ane po linii MOSI i odbierane na linii MISO. Tryb SPI wspiera wiêkszoœæ komend u¿ywanych w komunikacji z kartami SD. Implementacja tego protoko³u jest du¿o ³atwiejsza ni¿ specyficznego SD Bus, dlatego jest to popularniejsze rozwi¹zanie i zdecydowanie lepiej udokumentowane. Wiêkszoœæ dzisiejszych mikrokontrolerów posiada konfigurowalne peryferium SPI. W przypadku jego braku, mo¿na ³atwo zaimplementowaæ komunikacjê na zwyk³ych wyjœciach cyfrowych~\cite{spec:sd}.

\subsection{Direct Memory Acces (DMA)} \label{sec:sub:dma}
Bardzo wiele operacji wykonywanych na blokach danych polega tylko na ich kopiowaniu. Nie ma potrzeby anga¿owaæ do tego procesu rejestrów CPU (jednostki steruj¹cej). Na potrzeby kopiowania danych, bez u¿ycia procesora stworzono blok DMA (Direct Memory Acces). Je¿eli rozpatrywaæ peryferia jako zmapowan¹ pamiêæ, mo¿na u¿ywaæ DMA do kopiowania danych z peryferiów do bloków pamiêci wewnêtrznej lub odwrotnie. Obs³uga karty SD mo¿e odbywaæ siê przy u¿yciu modu³u DMA, dziêki czemu mo¿na wskazaæ kontrolerowi DMA blok pamiêci, który ma zostaæ skopiowany do karty, a zapis odbêdzie siê bez u¿ycia procesora.
