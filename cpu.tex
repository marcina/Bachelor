Komputer pok³adowy sk³ada siê z dwóch elementów: p³ytki ewaluacyjnej STM32\-F4\-Dis\-co\-ve\-ry oraz nak³adki rozszerzaj¹cej jej mo¿liwoœci. G³ównym podzespo³em komputera pok³adowego jest mikrokontroler serii STM32F4.

\subsection{Mikrokontroler} \label{sec:sub:mcu}
Nazwa serii reprezentuje kolejno nazwê producenta - STMicroelectronics, wielkoœæ pojedynczego rejestru - 32 bity oraz wersjê rdzenia - Cortex™-M4 CPU firmy ARM \cite{article:discovery}\cite{manual:discovery}. Jest to podrodzina rdzeni zoptymalizowana pod k¹tem minimalizacji ceny przy zachowaniu du¿ej wydajnoœci, przeznaczona do zastosowañ konsumenckich i przemys³owych \cite{book:paprocki}. Powodem wyboru tej platformy sprzêtowej jest spe³nienie przez ni¹ wszystkich za³o¿eñ projektu odnoœnie jednostki steruj¹cej oraz posiadanych uk³adów peryferyjnych \cite{manual:stm32f4d}. Uk³ad musi 
\begin{itemize}
\item byæ szybki - 168 MHz,
\item byæ niezawodny - dwa timery typu watchdog,
\item posiadaæ rozszerzenie SDIO do obs³ugi kart SD\\
(\hyperref[sec:sd]{Sekcja~\ref*{sec:sd}: Archiwizacja danych - SD}),
\item posiadaæ magistralê CAN do komunikacji z uk³adami pomocniczymi\\ (\hyperref[sec:can]{Sekcja~\ref*{sec:can}: G³ówna magistrala komunikacyjna - CAN}),
\item posiadaæ uk³ad UART do komunikacji z nadajnikiem XBee\\
(\hyperref[sec:xbee]{Sekcja~\ref*{sec:xbee}: Komunikacja bezprzewodowa - XBee})
\item byæ ³atwy w  programowaniu, co umo¿liwi³a rozbudowana biblioteka dostarczana przez producenta,
\end{itemize}
Zastosowanie nak³adki rozszerzaj¹cej funkcjonalnoœæ Discovery pozwala znacznie u³atwiæ proces projektowania skracaj¹c go znacznie.

\subsection{Obs³uga magistrali CAN}
G³ówn¹ magistral¹ komunikacyjn¹ w systemie jest Controller Area Network opisany w \hyperref[sec:can]{Sekcji~\ref*{sec:can}: G³ówna magistrala komunikacyjna - CAN}. Implementacja komunikacji przy wykorzystaniu tej magistrali by³a g³ównym celem projektu. Komunikacja mo¿liwa jest dziêki kontrolerowi magistrali CAN zintegrowanemu w mikrokontrolerze. Posiada on trzy skrzynki nadawcze i dwie odbiorcze, które mieszcz¹ po trzy wiadomoœci. Dodatkowo wyposa¿ony jest w bank filtrów akceptacyjnych, które mo¿na dowolnie przypisaæ do dwóch interfejsów CAN, po 14 do ka¿dego. Odbiór wiadomoœci odbywa siê automatycznie i jest realizowany sprzêtowo, podobnie jak wstêpna selekcja nadchodz¹cych komunikatów. Filtry odci¹¿aj¹ procesor, sortuj¹c wiadomoœci.~\cite{manual:stm32f4}.\\
Dziêki u¿yciu protoko³u CAN system ma mo¿liwoœæ odczytywania danych ze sterownika silnika ECU serii PE3, który wysy³a wiadomoœci przy u¿yciu standardu bazuj¹cego na SAE J1939. Dok³adna znajomoœæ standardu SAE J1939 nie jest potrzebna w celu zbudowania systemu mog¹cego siê komunikowaæ ze sterownikiem. Producent do³¹cza notê katalogow¹~\cite{manual:ecu}, w której opisane s¹ wszystkie mo¿liwe komunikaty, które sterownik wysy³a. 

\subsubsection{Przestrzeñ adresowa CAN} \label{ssec:adresowanie}
Ka¿dy identyfikator w standardzie SAE J1939, u¿ywanym w sterowniku ECU, oparty jest na rozszerzonej wersji standardu CAN i posiada 29 bitów. Ka¿da wiadomoœæ, posiadaj¹ca w³asny identyfikator, niesie ze sob¹ 7 lub 8 bajtów danych, czyli maksymaln¹ iloœæ przewidzian¹ przez standard CAN. Producent sterownika ECU do³¹cza instrukcjê s³u¿¹c¹ do dekodowania ramki, w celu uzyskania pojedynczych informacji zawartych w 8-bajtowym komunikacie~\cite{manual:ecu}. Na podstawie identyfikatorów u¿ywanych przez ECU zbudowano system identyfikatorów wystêpuj¹cych w systemie. Pomimo i¿ identyfikator przypisany jest do wiadomoœci, a nie do urz¹dzenia, utworzono system filtrów, który jednoznacznie okreœla, który wêze³ magistrali nades³a³ wiadomoœæ. Format identyfikatora przedstawiono na \hyperref[fig:identyfikatory]{Rysunku~\ref*{fig:identyfikatory}} i jest to przyk³ad identyfikatora u¿ywanego przez sterownik silnika ECU.

\begin  {figure} [h] 
\centering
\includegraphics[width=0.3\textwidth]{figures/Adress.JPG}
\caption{Budowa identyfikatora CAN}
\label{fig:identyfikatory}
\end {figure}

\begin{itemize}
\item Segment A odpowiedzialny jest za adres urz¹dzenia i przybiera wartoœci od 0x06 do 0x12. Zakres ten umo¿liwia  obs³ugê do 13 pod³¹czonych urz¹dzeñ (HUB 0 - HUB 12). Jest to niewielka iloœæ, bior¹c pod uwagê mo¿liwoœci jakie oferuje standard CAN. Nie zak³ada siê jednak wiêkszej potrzeby. Adresowanie zosta³o tak skonstruowane, aby identyfikator ECU, którego segment A wynosi 0x0C znajdowa³ siê w œrodku zakresu (HUB 6). Pamiêtaj¹c, ¿e identyfikator wiadomoœci jest jednoczeœnie jej priorytetem, takie roz³o¿enie identyfikatorów pozwala z du¿¹ dowolnoœci¹ ustawiaæ system priorytetów pomiêdzy wêz³ami.\\
\item Segment B odpowiedzialny jest za rozró¿nienie, co zawiera komunikat. W sterowniku ECU s¹ to wartoœci od 0x0 do 0x6. Aby zdekodowaæ komunikat nadawany przez ECU, nale¿y odnieœæ siê do noty katalogowej~\cite{manual:ecu}. Pozosta³e wêz³y przyjmuj¹ w segmencie B wartoœci od 0x0 do 0xA. Ka¿da identyfikator skojarzony jest z kana³em przetwornika anlogowo-cyfrowego, który jest czêœci¹ architektury jednostki pomiarowej. Przetworniki posiadaj¹ rozdzielczoœæ 12 bitów, dziêki czemu wystarcz¹ dwa bajty danych na przes³anie wiadomoœci. Ka¿da wiadomoœæ posiada swój identyfikator, dziêki czemu wynikiem filtrowania wiadomoœci bêdzie dok³adna informacja o stanie konkretnego wejœcia analogowego jednostki pomiarowej.
\end{itemize}
Adresowanie wiadomoœci przedstawiono na \hyperref[fig:adresowanie]{Rysunku~\ref*{fig:adresowanie}}. Nieu¿ywane bajty w identyfikatorze stanowi¹ mo¿liwoœæ do rozszerzenia funkcjonalnoœci systemu.

\begin  {figure} [h] 
\centering
\includegraphics[width=0.75\textwidth]{figures/Adresowanie.JPG}
\caption{Adresowanie}
\label{fig:adresowanie}
\end {figure}

\subsubsection{Filtry akceptacyjne} \label{ssec:filtry}
Kontroler magistrali CAN wyposa¿ony jest w w sprzêtowe filtry akceptacyjne. Na ka¿dy z dwóch interfejsów CAN przypada 14 filtrów akceptacyjnych. Bank filtrów mo¿na skonfigurowaæ na kilka sposobów. Po pierwsze nale¿y wybraæ wersjê wspieranego protoko³u (Wiêcej o wersjach protoko³u CAN w \hyperref[sec:can]{Sekcji~\ref*{sec:can}: G³ówna magistrala komunikacyjna - CAN}. W przypadku omawianego systemu jest to wersja z rozszerzonym polem identyfikatora. Programista uzyskuje dostêp do 32-bitowych rejestrów, które mo¿na ustawiæ w tryb listy identyfikatorów lub maskowania. Filtrowanie na podstawie listy identyfikatorów polega na porównaniu identyfikatora nadchodz¹cej wiadomoœci z identyfikatorem znajduj¹cym siê w 32-bitowym rejestrze. Tryb maskowania polega na dodatkowym zdefiniowaniu maski, która wskazuje, które bity identyfikatora nadchodz¹cej wiadomoœci maj¹ zostaæ porównane z rejestrem w pamiêci procesora. Nale¿y pamiêtaæ o tym, ¿e identyfikatory posiadaj¹ tylko 29 bitów, a wiêc wartoœæ w rejestrze jest wyrównana do lewej, czyli w stronê najbardziej znacz¹cego bitu. Odwo³uj¹c siê do wartoœci w rejestrze nale¿y przesun¹æ go o 3 bity w lewo, aby odczytywaæ 29 najbardziej znacz¹cych bitów. Przyk³ad przedstawiono na \hyperref[listing:mask]{Listingu~\ref*{listing:mask}}.

\noindent \begin{minipage}{\textwidth}
\begin{lstlisting}[captionpos=b, belowcaptionskip=8pt, caption=Maska akceptacyjna, label=listing:mask]
#define CAN_ID_HUB6 0x0CFFF048 // 0 1100 1111 1111 1111 0000 0100 1000
#define CAN_ID_MASK 0x1F000000 // 1 1111 0000 0000 0000 0000 0000 0000
CAN_FilterInitStructure.CAN_FilterIdHigh = (uint16_t)((CAN_ID.HUB[i].ID <<3) >>16);
CAN_FilterInitStructure.CAN_FilterIdLow = (uint16_t)(CAN_ID.HUB[i].ID<<3);
CAN_FilterInitStructure.CAN_FilterMaskIdHigh = (uint16_t)((CAN_ID.Mask <<3) >>16);
CAN_FilterInitStructure.CAN_FilterMaskIdLow = (uint16_t)(CAN_ID.Mask <<3);
\end{lstlisting}
\end{minipage}

W systemie u¿yto trybu maskowania filtrów. Utworzono bank 14 filtrów przypisanych do interfejsu CAN1. Ka¿dy filtr ma tê sam¹ maskê 0x1F000000, przedstawion¹ na \hyperref[listing:mask]{Listingu~\ref*{listing:mask}} oraz w³asne ID, na które maska jest nak³adana. Porównywanych jest tylko 5 pierwszych bitów (zamiast 29) identyfikatora, co skraca czas odbierania wiadomoœci. Proces akceptacji wiadomoœci polega na wykonaniu iloczynu logicznego maski oraz identyfikatora nadchodz¹cej wiadomoœci, a nastêpnie porównaniu maskowanych bitów (gdzie maska jest równa 1) z identyfikatorem zapisanym w rejestrze procesowa. W przypadku niezgodnoœci operacja powtarzana jest dla kolejnych filtrów. Przy dalszej niezgodnoœci, wiadomoœæ jest ignorowana (bez u¿ycia zasobów procesora). W przypadku udanego porównania, wiadomoœæ trafia do skrzynki odbiorczej i wywo³ywane jest przerwanie odbioru wiadomoœci. Dziêki formie maski porównaniu ulega tylko segment A identyfikatora (patrz: \hyperref[fig:identyfikatory]{Rysunek~\ref*{fig:identyfikatory}}). Do skrzynki odbiorczej trafia wiadomoœæ z numerem filtru, czyli poœrednio z numerem wêz³a, który wiadomoœæ wys³a³. Numer filtru przechowywany jest wraz z wiadomoœci¹ w zmiennej FMI (Filter Match Index) (wiêcej w \hyperref[ch:eksperyment]{Rozdziale~\ref*{ch:eksperyment}: Badania eksperymentalne}). Program ma za zadanie porównanie tylko jednego bajtu identyfikatora (segmentu B) w celu odkrycia, który kana³ przetwornika ADC zosta³ zapisany do pola danych wiadomoœci.

\subsubsection{Transceiver CAN}
Kontroler magistrali CAN, w który wyposa¿ony jest procesor, posiada dwie asynchroniczne linie danych. S¹ to jednokierunkowe linie Rx oraz Tx. Aby pod³¹czyæ kontroler do magistrali, na której wystêpuj¹ sygna³y Can High oraz Can Low, nale¿y szeregowe komunikaty binarne skonwertowaæ na sygna³ ró¿nicowy. Konwersj¹ komunikatu oraz dostosowaniem napiêæ zajmuje siê Transceiver CAN. Modu³ u¿yty w projekcie to L9616~\cite{manual:can}. Aby uchroniæ uk³ad g³ównego komputera od szpilek wysokich napiêæ, które mog³yby przedostaæ siê z magistrali, oraz od zak³óceñ na masie, u¿yto dwukana³owej izolacji galwanicznej w module ISO7221~\cite{manual:iso}. Izoluje ona zarówno linie sygna³owe, jak i zasilania, oddzielaj¹c uk³ad transceivera od g³ównego komputera. Schemat przedstawiono na \hyperref[fig:transceiver]{Rysunku~\ref*{fig:transceiver}}.

\begin  {figure} [h] 
\centering
\includegraphics[width=0.75\textwidth]{figures/Transceiver_schemat.JPG}
\caption{Schemat Tranceivera CAN z izolacj¹ galwaniczn¹}
\label{fig:transceiver}
\end {figure}

Zworki JP1 oraz JP2 umo¿liwiaj¹ zasilenie magistrali z tego samego Ÿród³a, z którego zasilany jest g³ówny komputer pok³adowy (lub HUB, gdy¿ w obu urz¹dzeniach wystêpuj¹ bliŸniacze uk³ady transceiverów). Diody sygnalizuj¹, czy aktualnie odbywa siê transmisja. 

\subsection{Obs³uga karty SD}
Obs³uga karty SD odbywa siê poprzez protokó³ SD Bus, przy u¿yciu zintegrowanego peryferium SDIO (Secure Digital Input Output) mikrokontrolera. SDIO s³u¿y do obs³ugi funkcji wejœcia/wyjœcia urz¹dzeñ zgodnych ze standardem SD~\cite{spec:sd}. Wyró¿niane s¹ trzy fizyczne topologie sieci. Przy u¿yciu fizycznej warstwy protoko³u SPI, SD Bus z jedn¹ lub czterema liniami danych. W projekcie u¿yto standardu 4-bitowego. Na \hyperref[fig:sd_schemat]{Rysunku~\ref*{fig:sd_schemat}} pokazano realizacjê warstwy fizycznej protoko³u SD Bus u¿yt¹ w projekcie. Linie danych i komend musz¹ posiadaæ podci¹gniêcia do zasilania. Interfejs SPI oraz SD Bus 1-bitowy (na którym wykonywano testy) nie s¹ kompatybilnymi interfejsami. Nale¿y przygotowaæ odpowiednio warstwê fizyczn¹ aby unikn¹æ problemów podczas implementacji programu.

\begin  {figure} [h] 
\centering
\includegraphics[width=0.5\textwidth]{figures/sd_schemat.JPG}
\caption{Schemat pod³¹czenia slotu karty SD zgodnie z SD Bus 4-bitowym}
\label{fig:sd_schemat}
\end {figure}

Wszystkie karty SD s¹ kompatybilne ze standardem SDIO, który zapewnia ich obs³ugê w ich ograniczonym zakresie (bez u¿ycia poleceñ wejœcia/wyjœcia). Do urz¹dzeñ wykorzystuj¹cych pe³niê potencja³u protoko³u SDIO zalicza siê miêdzy innymi kamery, karty bluetooth, odbiorniki GPS. Obs³uga tych urz¹dzeñ ró¿ni siê, ale wszystkie s¹ zgodne ze standardem SDIO~\cite{spec:sdio}.\\
Bazuj¹c na za³o¿eniach projektu zaimplementowano obs³ugê karty SD przez kontroler DMA, skracaj¹c czas operacji na plikach. U¿yta w tym celu biblioteka jest autorstwa Tilen'a Majerle~\cite{lib:sd}. Tilen Majerle zapewnia sta³e wsparcie dla biblioteki, która posiada swoje wady i udziela odpowiedzi na pytania u¿ytkowników. U³atwia to w znacz¹cym stopniu implementacjê biblioteki i jej póŸniejsze u¿ycie i zintegrowanie z pozosta³¹ czêœci¹ programu. Wa¿nym elementem biblioteki jest funkcja pozwalaj¹ca na zapisywanie sformatowanego tekstu do pliku \textit{fprintf (FILE * stream, const char * format, ... )}.\\
Mikrokontroler posiada dwa kontrolery DMA, ka¿dy maj¹cy 8 strumieni, dziel¹cych siê na 8 kana³ów. Utworzona w ten sposób macierz 64 pól oraz przypisane do nich peryferia przedstawiono w tabelach 35. oraz 36. RM0090 Reference manual~\cite{manual:stm32f4}. Ró¿nice w obs³udze karty przy u¿yciu protoko³u SPI, SD BUS 1-bitowego oraz 4-bitowego zawarto w \hyperref[ch:eksperyment]{Rozdziale~\ref*{ch:eksperyment}: Badania eksperymentalne}.\\
Polecenia u¿yte podczas obs³ugi karty SD s¹ standardowymi zestawami komend oraz argumentów. Przyk³adowe komendy omówione s¹ w specyfikacji Secure Digital Card Product Manual (Sekcja 4.7 Commands)~\cite{manual:sandisk}.

\subsection{Obs³uga modu³u XBee}
Wyró¿niane s¹ dwie wersjê modu³u XBee. Jedna zawiera wbudowan¹ antenê radiow¹, druga umo¿liwia wyprowadzenie anteny poza p³ytkê PCB. Zdecydowano siê na wariant urz¹dzenia z zewnêtrzn¹ anten¹ w celu zwiêkszenia zasiêgu.  Zrezygnowano z pinów RTS oraz CTS, rezygnuj¹c tym samym z kontroli przep³ywu danych, ale przy dobrze zaprogramowanej komunikacji nie s¹ one wymagane. Modu³ dzia³a jednokierunkowo, bez sprawdzania, czy wiadomoœæ dotar³a do celu. Aby uzyskaæ szybszy przekaz danych ustawiono modu³ w tryb transparentny (wiêcej w \hyperref[sec:sub:tryby]{Sekcji~\ref*{sec:sub:tryby}: Tryby pracy modu³u XBee}). Schemat modu³u przedstawiono na \hyperref[fig:xbee_schemat]{Rysunku~\ref*{fig:xbee_schemat}}

\begin  {figure} [h] 
\centering
\includegraphics[width=0.5\textwidth]{figures/xbee_schemat.JPG}
\caption{Schemat pod³¹czenia radiowego modu³u XBee}
\label{fig:xbee_schemat}
\end {figure}

Komunikacja z modu³em odbywa siê dziêki zintegrowanemu w mikrokontrolerze modu³owi UART. Na linii DOUT modu³u mikrokontrolera wysy³ana jest kopia ramki CAN, tak aby umo¿liwiæ jej podgl¹d w interfejsie u¿ytkownika. Jest to na³o¿enie protoko³u CAN na asynchroniczn¹ szeregow¹ pojedyncz¹ liniê danych. Ramka przesy³ana jest jako strumieñ, czyli ci¹g znaków ASCII (tablica znaków koñcz¹ca siê znakiem NULL). Jest to reprezentacja wartoœci ramki w systemie szesnastkowym. Do przes³ania sformatowanego tekstu po UART u¿yto funkcji USARTSendCan, przedstawionej na \hyperref[listing:usart]{Listingu~\ref*{listing:usart}}\\

%\noindent\begin{minipage}{\textwidth}
%\begin{lstlisting}[captionpos=b, belowcaptionskip=8pt, caption=Funkcja enkaspulacyji danych USART_SendCan, label=listing:usart]
%%void USART_SendCanFrame (CanRxMsg RxMessage)
%%{
%%	int i = 0;
%%	char string[27];
%%	string[0]='\\0';
%%	char b[9];
%%	b[0] = '\\0';
%%	sprintf(b,"%08x",(unsigned int)RxMessage.ExtId);
%%	strcat(string,b);
%%	sprintf(b,"%02x",(unsigned int)RxMessage.DLC);
%%	strcat(string,b);
%%	for (;i<RxMessage.DLC;i++)
%%	{
%%		sprintf(b,"%02x",(unsigned int)RxMessage.Data[i]);
%%		strcat(string,b);
%%	}
%%	USART\_printf("%s",string);
%%}
%\end{lstlisting}
%\end{minipage}
%\\
Dla przyk³adu, chc¹c przes³aæ wartoœæ 0x01ABC, zostanie przes³ane s³owo "01abc", czyli ci¹g znaków 0x30 0x31 0x61 0x62 0x63 0x00.\\

Takie podejœcie umo¿liwia kontrolê koñca ramki CAN (znak NULL). Ramka sk³ada siê tylko z identyfikatora CAN, kody DLC oraz pola danych.\\
Aby rozpocz¹æ pracê z modu³em nale¿y zdefiniowaæ wpierw jego parametry. Ustawiæ inn¹ prêdkoœæ transmisji (BD), parzystoœæ (NB), bity stopu (SB) oraz inne parametry modu³u przy u¿yciu komend AT (dostêpnych w Rozdziale 10. XBee®/XBee-PRO® ZB SMT RF Modules Datasheet~\cite{manual:xbee}). W tym celu nale¿y wprowadziæ modu³ w tryb odbioru komend AT przy u¿yciu specjalnej komendy oraz parametrów domyœlnych transmisji, czyli 9600 b/s, 1 bit stopu i brak bitu parzystoœci.\\
Po zakoñczeniu inicjalizacji mo¿na albo poczekaæ a¿ modu³ sam wróci do trybu wysy³ania danych przez antenê, albo wymusiæ powrót. Po powrocie w tryb przesy³ania danych, modu³ przesy³a kopiê ramki CAN, która zosta³a w danej chwili odebrana przez komputer g³ówny i wysy³a j¹ do uk³adu odbiorczego, wspó³pracuj¹cego z interfejsem u¿ytkownika.
Dioda sygnalizuje, czy urz¹dzenie zosta³o sparowane z odbiornikiem czy nie, zmieniaj¹c czêstotliwoœæ œwiecenia.

\subsection{Zasilanie}

\subsection{System przerwañ}
Przy obs³udze tak wielu uk³adów peryferyjnych wa¿ne jest zachowanie pewnego systemu priorytetów przerwañ, które mog¹ zostaæ zg³oszone jednoczeœnie. S³u¿y do tego uk³ad NVIC (Nested Vector Interrupt Controller) zintegrowany w procesorze. W systemie wyró¿niamy nastêpuj¹ce przerwania:
\begin{itemize}
\item odbioru wiadomoœci na magistrali CAN,
\item koñca przesy³u wiadomoœci przez kontroler DMA,
\item koñca przetwarzania wiadomoœci przez SDIO,
\item od modu³u UART,
\item wsuniêcia/wysuniêcia karty SD do/ze slotu,
\item od timera watchdog,
\item od timerów pomocniczych.
\end{itemize}

Procesor umo¿liwia zdefiniowanie grup przerwañ, które maj¹ wy¿szy priorytet. W systemie u¿yto dwóch grup g³ównych (preemption priority group) z siedmioma podgrupami (sub priority group) w celu uszeregowania priorytetów. Zapewniono najwy¿szy priorytet timerowi watchdog, gdy¿ jest istotne aby zosta³o ono obs³u¿one w skoñczonym czasie. W przypadku, gdy podczas obs³ugi dowolnego przerwania (lub wykonywania pêtli while()), system zawiesi siê i nie zostanie obs³u¿one przerwanie od timera watchdog, system ulegnie resetowi. Kolejn¹ grup¹ s¹ przerwania odpowiedzialne za timery, nastêpnie za komunikacjê, a na koñcu przerwanie zewnêtrzne (karta SD). Taki system priorytetów zapewnia spe³nienie czasowych ograniczeñ narzuconych systemowi przez iloœæ operacji do wykonania w okresie próbkowania przetworników.